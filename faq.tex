\documentstyle{article}
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}
\begin{document}
\section{UNIX System Calls}
\begin{enumerate}
\item Consider the C function ‘printf()’ on UNIX. Is printf() implemented by the OS,
or by an
application-level library? What system call does
printf() make internally? 

\item Why are {\tt mkdir}, {\tt ln} and {\tt rm} implemented as separate user-level programs, while {\tt cd} is implemented as a built-in command?

\item On a linux machine, type the following command
\begin{verbatim}
$ cat | tee output.file
\end{verbatim}
cat is a UNIX utility that prints the contents of STDIN to STDOUT. tee is a UNIX utility that prints the contents of STDIN to both STDOUT and to the file named by its argument (output.file). After you type this command, you can type in some characters followed by the newline character.

\begin{enumerate}
\item[a.] While this command is running, examine the processes created:
\end{enumerate}

Use pstree to see the process hierarchy. Tell us what you find about the process hierarchy.
Use 'ps x' to identify the process IDs of the processes created by cat and tee commands. Linux provides a proc pseudo-filesystem which can be used to examine the state of a process using filesystem namespace.

Type the following command for both process-ids:
\begin{verbatim}
$ ls -l /proc/pid-num/fd/
\end{verbatim}

\begin{enumerate}
\item[b.] What do you find? What are 0,1,2,...? What do they symlink to?
\end{enumerate}

\begin{verbatim}
$ ls -l /proc/self/fd/
\end{verbatim}

\begin{enumerate}
\item[c.] What do you find? What is 3 pointing to? Why?
\item[d.] Which system calls are executed while you run {\tt cat}, {\tt tee}, and {\tt ls} as in the above commands?
\end{enumerate}

\item Assume you are given two text files containing newline-separated strings. You wish to write
a program that takes as input two text files and outputs another text file that contains all the
strings that are common in the two input files. For example, if the two text files are {\tt foo}
and {\tt bar}, with the following contents:
\begin{verbatim}
foo:
hello
os
class
\end{verbatim}
\begin{verbatim}
bar:
os
is
an
interesting
class
\end{verbatim}
Then, the output would be:
\begin{verbatim}
output:
os
class
\end{verbatim}
({\tt os} and {\tt class} are common words in the two files). Assume you are given the following
functions:
\begin{enumerate}
\item[i.] A function {\tt cat()} that takes input from its first argument and displays its
content on the standard output (file-descriptor 1). e.g.,
\begin{verbatim}
cat(foo);
\end{verbatim}
This function call will cause the contents of the file {\tt foo} to get streamed to the standard
output of the program.
\item[ii.] A function {\tt sort()} that takes input from its standard input (file-descriptor 0),
sorts the input text (assuming it consists of newline-separated words), and prints the output
to standard output (file-descriptor 1).
\item[iii.] A function {\tt intersect()} that takes input from file descriptors 3 and 4 (non-standard
file descriptors). It assumes that both inputs (from each file descriptor) are sorted, and computes
the intersection of the sorted streams of words, outputting to the standard output (file descriptor 1).
\item[iv.] The {\tt dup()}, {\tt pipe()} and {\tt fork()} system calls.
\end{enumerate}
You are not allowed to use any other system calls (e.g., {\tt open}, {\tt read}, etc.) or any
other functions. Using these functions, implement a utility that given two filenames, outputs
the common strings in the two files on the standard output.

\item What is the total number of processes at the end of the execution of the following program? Assume there is one process in the beginning that starts running at main. Also, assume that all system calls succeed.
\begin{verbatim}
main() {
  fork();
  fork();
  fork();
}
\end{verbatim}
Explain. 

\item
Consider the following program:
\begin{verbatim}
main() {
    int fd;
    fd = open(“outfile”, O_RDWR)
    fork();
    write(fd, “hello”, 5);
    exit();
}
\end{verbatim}
Assume all system calls finish successfully on a uniprocessor system. Also, assume that a system call cannot be interrupted in the middle of its execution. What will be the contents of the “outfile” file, after all processes have successfully exited? Explain briefly.

\item
Consider the following program:
\begin{verbatim}
main() {
    int fd;
    fd = open(“outfile”, O_RDWR)
    fork();
    write(fd, “hello”, 5);
    exit();
}
\end{verbatim}
Assume all system calls finish successfully on a uniprocessor system. Also, assume that a system call cannot be interrupted in the middle of its execution. What will be the contents of the “outfile” file, after all processes have successfully exited? Explain briefly.

\item Give two interesting applications where you think the user-defined SIGUSR1 and
SIGUSR2 can be useful?

\item
In UNIX, a child process may terminate before a parent calls wait(). When the parent calls wait() eventually, it still expects to read the correct exitcode that the child returned. To support this functionality, UNIX does not completely remove the process till it's parent has called wait() on it.
\\\\
Such processes that have completed execution but still have an entry in the process table are called zombie processes. Usually, the presence of zombie processes in the system for a long time indicates a bug in the program (it is a common error).
\\\\
UNIX also provides the SIGCHLD signal, which is received by the parent process whenever one of
its children exits.
\\\\
In class we discussed that the shell implements ``\&" functionality by not
calling wait() immediately. Should the shell never call wait()? When should it call wait()? Answer by providing short pseudo-code. (Hint: you may want to use the SIGCHLD signal).


\item
UNIX uses {\tt fork()} and {\tt exec()} system calls to create new processes. On the other hand, Microsoft
Windows has a system call called {\tt CreateProcess()}.
Here is a sample definition of the
{\tt CreateProcess()} call
(this is not identical but similar to Windows’ system call):
\begin{verbatim}
Boolean CreateProcess(
    lpApplicationName,    /* Name of the executable. */
    lpCommandLine,        /* Command line parameters. */
    bInheritHandles,      /* Boolean variable indicating if the new process
                             should inherit the open file descriptors of the
                             calling process. */
    lpProcessAttributes,  /* attributes of security attributes of process. */
    lpCurrentDirectory,   /* current working directory of new process. */
    lpProcessInformation  /* A pointer to Process Information structure that
                             receives identification information about the
                             new process. */
. . . /* ignoring some other arguments. */
);
\end{verbatim}
Write code to implement the equivalent of this call on UNIX. You should show how you use
{\tt lpApplicationName}, {\tt lpCommandLine}, {\tt bInheritHandles},
{\tt lpProcessAttributes}, {\tt lpCurrentDirectory}, and {\tt lpProcessInformation}
on
UNIX.

\item Write the pseudo-code for a program ``{\tt cp}'' that takes two command-line arguments, say input-file and output-file, copies the input-file to the output-file.
\begin{verbatim}
Syntax:
$ cp ifile ofile

Program:

int main(int argc, char **argv)
{
  //your solution goes here.
  //Use UNIX system calls to implement the logic.
}
\end{verbatim}

\end{enumerate}

\section{Threads}
\begin{enumerate}
\item What is an address space? How does the operating system ensure that a variable
of one program/process does not clobber a variable of another process?
\item Each process has a separate address space. When is the new address space created?
\item What are threads? How are they different from processes? What are the advantages?
Give examples to motivate the use of threads.
\item What is the difference between user-level threads and kernel-level threads?
Do user-level threads provide true physical concurrency? If not, why are they useful?

\item
Threads can be implemented completely at the user level. i.e., we do not require privileged operations to implement a thread abstraction and schedule different threads. In other words, a process can provide multiple threads by implementing a scheduler. Let's see how this can be done.
\\\\
To implement threads, the process needs to provide the abstraction of multiple control-flow (program counter), multiple register sets and multiple stacks. This can be done if after every periodic time interval, one thread can be interrupted and saved and another thread can be loaded. Saving a thread involves saving it's program counter, registers and stack pointer. Similarly, loading a thread involves loading the new thread's program counter, registers and stack pointer. Neither the save operation, nor the load operation requires any privileged operation -- we are just loading and saving registers.
\\\\
So the only remaining issue is how to periodically interrupt a running thread from within a process. For an OS, this interruption is done by the hardware timer device. A process can do this using the SIGALRM signal.
\\\\
Such threads implemented inside a process are called user-level threads. The OS cannot distinguish between multiple user-level threads and it can only see one process that is running which includes the thread scheduler and the different threads.
\\\\
Read the manpage of the signal, alarm, and setitimer. Understand how SIGALRM can help in
implementing user-level threads. Briefly describe how you will do
this (2-3 sentences and some pseudo-code). 


\end{enumerate}

\section{PC Architecture and Compiler Conventions}
\begin{enumerate}
\item Consider the following function:
\begin{verbatim}
int32_t global;

int32_t foo(int32_t a, int32_t *b) {
  int32_t c;

  c = global + a;
  
  return *(b + c);
}
\end{verbatim}
Assume that the variable global is allocated at a global address 0x12345. Write
the assembly code for this function, with proper comments on which assembly code
lines are implementing which C statement. Assume GCC calling conventions. You will
need to be careful about properly naming all variables and
arguments (e.g., using global addresses, stack offsets or frame pointer offsets),
use proper opcodes and addressing modes, obey caller and callee-save conventions, etc. 

\item A new compiler ‘{\tt hcc}’ is developed. What should {\tt hcc} be careful about if it wants to use the
libraries that were compiled using {\tt gcc}?

\item To implement function calls, typically compilers use conventions about which registers
to save. Some registers are saved by the caller (before the call instruction) and some
registers are saved by the callee (in the function body). For example, gcc follows the
following convention on x86:
\begin{verbatim}
    %eax, %ecx, %edx are "caller save" registers (saved by caller)
    %ebp, %ebx, %esi, %edi are "callee save" registers (saved by callee) 
\end{verbatim}
Why is a convention needed?
Give an example of a program where using the convention of caller and callee saved registers helps in reducing the number of saves and restores of registers during function calls. What should the compiler be careful about to maximize this optimization opportunity? Hint: Are the values of all registers useful (i.e., will they be used in future). If a value in a register will be used in subsequent instructions, that register is called live. If a value in a register will not be used in future (e.g., it will get overwritten by another value), that register is called dead. Can the caller save only live registers and ignore dead registers? What about callee? How does splitting into caller-saved and callee-saved registers improve this optimization opportunity? For example, which registers should the caller try to use first for storing its temporary values? Similarly, which registers should the callee try to use first for storing its temporary values? Why?) 

\item Look at the following program:
\begin{itemize}
\item C code
\begin{verbatim}
int main(void) { return f(8)+1; }
int f(int x) { return g(x); }
int g(int x) { return x+3; }
\end{verbatim}
\item Assembly code
\begin{verbatim}
_main:
  __prologue__
  pushl %ebp
  movl %esp, %ebp
  __body__
  pushl $8
  call _f
  addl $1, %eax
  __epilogue__
  movl %ebp, %esp
  popl %ebp
  ret

_f:
  __prologue__
  pushl %ebp
  movl %esp, %ebp
  __body__
  pushl 8(%esp)
  call _g
  __epilogue__
  movl %ebp, %esp
  popl %ebp
  ret

_g:
  __prologue__
  pushl %ebp
  movl %esp, %ebp
  save %ebx
  pushl %ebx
  __body__
  movl 8(%ebp), %ebx
  addl $3, %ebx
  movl %ebx, %eax
  restore %ebx
  popl %ebx
  __epilogue__
  movl %ebp, %esp
  popl %ebp
  ret
\end{verbatim}
Notice that the function implementation only needs to obey the compiler conventions.
Another smaller (and faster) but correct implementation of {\tt g} is the following:
\begin{verbatim}
_g:
  movl 4(%esp), %eax
  addl $3, %eax
  ret
\end{verbatim}
\end{itemize}
What would be the smallest possible (but correct) implementation of {\tt \_f}?

\item Consider the following function:
\begin{verbatim}
int32_t global;
int32_t foo(int32_t a, int32_t *b) {
  int32_t c;
  c = global + a;
  return *(b + c);
}
\end{verbatim}
Assume that the variable global is allocated at a global address 0x12345. Write
the assembly code for this function, with proper comments on which assembly code
lines are implementing which C statement. Assume GCC calling conventions. You will
need to be careful about properly naming all variables and
arguments (e.g., using global addresses, stack offsets or frame pointer offsets),
use proper opcodes and addressing modes, obey caller and callee­save conventions, etc. It is
okay to not be exactly correct in the use of x86 opcodes, but the general layout of the code
and its logic should be correct.

\end{enumerate}

\section{Segmentation and Trap Handling}
\label{sec:segmentation}
\begin{enumerate}
\item
Consider the following program header of an ELF executable file {\tt a.out}:
\begin{verbatim}
LOAD: offset    0x00001000
      vaddr 0x40100000
      paddr 0x00100000
      align 2**12
      filesize 0x0000b596
      memsize 0x000126fc
      flags rwx
\end{verbatim}
Assume that this executable is loaded using the {\tt exec(“a.out”, …)} system call on 32-bit Linux.
Also, assume that the Linux kernel is mapped starting at virtual address {\tt 0xc0000000}.
\begin{enumerate}
\item[a.] Draw the layout of
the virtual address space of the process just after successful completion of
the exec() system call. Indicate the sizes, and the contents of the memory regions, wherever possible.
\item[b.] Draw the layout of the physical memory of the computer just after this
executable is loaded. Assume, segmentation is used for implementing virtual memory address
spaces. Show the contents of the segment registers (CS, DS, SS, etc.), the global-descriptor table, and
GDTR.
\end{enumerate}

\item The hardware does not allow an (unprivileged)
application to execute the {\tt lgdt} instruction (to load
the GDT). Why? What could happen if an application was allowed to execute the {\tt lgdt} instruction?

\item How does the OS ensure through segmentation that one application cannot access another
application's address space in the following situations:
\begin{enumerate}
\item The application tries to write to the physical address of the other application.
\item The application tries to modify the segment register
\item The application tries to overwrite GDT entries
\item The application tries to lower its privilege-level (i.e., tries to gain supervisor privileges).
\end{enumerate}
\item The instruction to load the Interrupt Descriptor Table Register (IDTR)
is ``{\tt lidt}'' and is a
privileged instruction, i.e., it can only be executed in privileged mode. Assume that it was
possible to execute this instruction in user mode by an untrusted user process. Show an
attack using this additional (hypothetical) capability, whereby:
\begin{itemize}
\item A user process can crash the machine.
\item A user process can read the memory contents of another process.
\end{itemize}
You should show the steps that the user process should follow to launch this attack in as
much detail as possible
\end{enumerate}
\section{Paging}
\begin{enumerate}
\item  Assume a memory access latency of 100ns, and a 2­level page table hierarchy on 32­bit
x86. What should be the TLB hit rate to ensure that the average memory access latency is
102ns. Assume there are no instruction/data caches in the hardware.

\item
Consider the following program header of an ELF executable file {\tt a.out}:
\begin{verbatim}
LOAD: offset    0x00001000
      vaddr 0x40100000
      paddr 0x00100000
      align 2**12
      filesize 0x0000b596
      memsize 0x000126fc
      flags rwx
\end{verbatim}
Assume that this executable is loaded using the {\tt exec(“a.out”, …)} system call on 32-bit Linux.
Also, assume that the Linux kernel is mapped starting at virtual address {\tt 0xc0000000}.
\begin{enumerate}
\item[a.] (repeat from Chapter~\ref{sec:segmentation}) Draw the layout of
the virtual address space of the process just after successful completion of
the exec() system call. Indicate the sizes, and the contents of the memory regions, wherever possible.
\item[b.] Assume that the operating system is using paging to map the pages of the executable on
x86 using a two­level page table. Also assume that it is not using large pages ­­­ i.e., it is only
using 4KB pages to map the process and kernel’s address space. Assume that the size of the
physical memory is 4MB and it is entirely mapped in the kernel address space (starting at
0xc0000000). Also, assume that the kernel’s code and data takes 1MB of physical memory
space (start at physical address 0x100000). Draw the page table and indicate the values stored
in them. Especially, say which entries will be present and where they will be mapped (what are
the likely values of these entries). Assume all space is mapped with rwx privileges (but of
course, differing in user/kernel privileges).
\end{enumerate}
\end{enumerate}
\section{Kernel Structures for Implementing Processes}
\begin{enumerate}
\item List a few in-memory data structures used by the kernel
to store information about processes. Which of these data structures are
visible to the process? How does the kernel ensure that all these structures
are protected from the untrusted process? What would be the typical space-overheads
of these data structures (you do not need to be exact, but some rough
estimates are good enough)? Compare these to typical process sizes (again, use
some representative programs that you use daily, and roughly estimate their
size).

\item {\tt malloc} and {\tt free} are functions available both for the kernel
and for the user programs. What is the difference between kernel's functions
and user program's functions? Can they have identical implementations --- what
are some necessary differences?

\item Explain the problem of fragmentation, in the context of malloc() and
free(). Compare and contrast this with the problem of fragmentation, as
it exists with segmentation-based virtual memory.
\end{enumerate}
\section{Process Switching, Fork, Scheduler}
\begin{enumerate}
\item Explain the steps involved in
\begin{itemize}
\item A context-switch that occurs because a process voluntarily calls {\tt yield()}.
\item A context-switch that occurs due to a pre-emptive context switch
triggered by a hardware timer interrupt.
\item A context-switch that occurs because a process tries to read from
the disk (slow device), which causes it to wait (and thus relinquish the CPU).
\end{itemize}
For each step, also indicate the approximate time it takes to execute that
step. For example, a trap takes a few micro-seconds (including saving and restoring
trapframes), saving and restoring registers, reloading page table, etc. Also,
briefly discuss the indirect cost of context-switch, e.g., TLB flush.

\item Estimate the cost of forking a new process. Compare the cost of fork,
with and without the copy-on-write optimization.

\item How does a doubly linked-list help in implementing a round-robin
scheduler? Why is a linked-list preferred over more complex data structures
like min-heap or binary-search trees, to implement process lists in the kernel?

\item Explain how context-switch can be implemented simply by switching
stacks. Do we need to save all registers, or only callee-saved registers on
a context-switch? Why?
\end{enumerate}
\section{Creating the First Process}
\begin{enumerate}
\item What is the typical functionality of the first process? What is its
purpose?
\item How is the first process initialized? Explain, using an example
program that can be used as a first process, while using UNIX abstractions.
\end{enumerate}
\section{Handling User Pointers}
\section{Concurrency}
\section{Locking}
\section{Condition Variables, Semaphores, Monitors, Transactions}
\section{Synchronization in xv6}
\section{Page Replacement}
\section{Storage Devices, Filesystem Interfaces}
\section{Filesystem Implementation}
\section{Filesystem Operations}
\section{Crash Recovery and Logging}
\section{Protection and Security}
\section{Scheduling Policies}
\section{Lock-free Synchronization}
\section{Microkernels, Exokernels, Multikernels}

\end{document}
